# Pieces of Redux

- **Store:** Store is a container that holds our application state(golbal data). It's a JavaScript object.
- **Actions:** Action is an object that describes something that happened in the application.
- **Dispatch:** The action object is dispatched to the store to tell it about what has happened.
- **Reducer:** When an action is dispatched, the store runs the reducer function, and lets it calculate the new state based on the old state and the action.


## Workflow

- A "store" is a container that holds your application's global state.
- You must never directly modify or change the state that is kept inside the Redux store.
- Instead, the only way to cause an update to the state is to create a plain action object that describes "something that happened in the application", and then dispatch the action to the store to tell it what happened.
- When an action is dispatched, the store runs the root reducer function, and lets it calculate the new state based on the old state and the action
- Finally, the store notifies subscribers that the state has been updated so the UI can be updated with the new data.


## Counter Example

1. We start by defining an initial state value to describe the application. Redux apps normally have a JS object as the root piece of the state, with other values inside that object.


```js
// Define an initial state value for the app
const initialState = {
  value: 0
}
```

2. Then, we define a reducer function. The reducer receives two arguments, the `current state` and an `action` object describing what happened. Reducer function determines the next state of our application based on the current state and action object.

```ts
// Create a "reducer" function that determines what the new state
// should be when something happens in the app
function counterReducer(state = initialState, action) {
  // Reducers usually look at the type of action that happened
  // to decide how to update the state
  switch (action.type) {
    case 'counter/incremented':
      return { ...state, value: state.value + 1 }
    case 'counter/decremented':
      return { ...state, value: state.value - 1 }
    default:
      // If the reducer doesn't care about this action type,
      // return the existing state unchanged
      return state
  }
}
```
