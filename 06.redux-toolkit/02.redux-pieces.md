# Pieces of Redux

- **Store:** Store is a container that holds our application state(golbal data). It's a JavaScript object.
- **Actions:** Action is an object that describes something that happened in the application.
- **Dispatch:** The action object is dispatched to the store to tell it about what has happened.
- **Reducer:** When an action is dispatched, the store runs the reducer function, and lets it calculate the new state based on the old state and the action.


## Workflow

- A "store" is a container that holds your application's global state.
- You must never directly modify or change the state that is kept inside the Redux store.
- Instead, the only way to cause an update to the state is to create a plain action object that describes "something that happened in the application", and then dispatch the action to the store to tell it what happened.
- When an action is dispatched, the store runs the root reducer function, and lets it calculate the new state based on the old state and the action
- Finally, the store notifies subscribers that the state has been updated so the UI can be updated with the new data.


## Counter Example

We start by defining an initial state value to describe the application. Redux apps normally have a JS object as the root piece of the state, with other values inside that object.

```js
// Define an initial state value for the app
const initialState = {
  value: 0
}
```

Then, we define a reducer function. The reducer receives two arguments, the `current state` and an `action` object describing what happened. Reducer function determines the next state of our application based on the current state and action object.

```ts
// Create a "reducer" function that determines what the new state
// should be when something happens in the app
function counterReducer(state = initialState, action) {
  // Reducers usually look at the type of action that happened
  // to decide how to update the state
  switch (action.type) {
    case 'counter/incremented':
      return { ...state, value: state.value + 1 }
    case 'counter/decremented':
      return { ...state, value: state.value - 1 }
    default:
      // If the reducer doesn't care about this action type,
      // return the existing state unchanged
      return state
  }
}
```

Action objects always have a `type` field, which is a string you provide that acts as a unique name for the action. The `type` should be a readable name so that anyone who looks at this code understands what it means.
Note that we update the state immutably by copying the existing state and updating the copy, instead of modifying the original object directly.
