# Pieces of Redux

- **Store:** Store is a container that holds our application state(golbal data). It's a JavaScript object.
- **Actions:** Action is an object that describes something that happened in the application.
- **Dispatch:** The action object is dispatched to the store to tell it about what has happened.
- **Reducer:** When an action is dispatched, the store runs the reducer function, and lets it calculate the new state based on the old state and the action.


## Workflow

- A "store" is a container that holds your application's global state.
- You must never directly modify or change the state that is kept inside the Redux store.
- Instead, the only way to cause an update to the state is to create a plain action object that describes "something that happened in the application", and then dispatch the action to the store to tell it what happened.
- When an action is dispatched, the store runs the root reducer function, and lets it calculate the new state based on the old state and the action
- Finally, the store notifies subscribers that the state has been updated so the UI can be updated with the new data.


## Counter Example

### State, Actions and Reducer

We start by defining an initial state value to describe the application. Redux apps normally have a JS object as the root piece of the state, with other values inside that object.

```js
// Define an initial state value for the app
const initialState = {
  value: 0
}
```

Then, we define a reducer function. The reducer receives two arguments, the `current state` and an `action` object describing what happened. Reducer function determines the next state of our application based on the current state and action object.

```ts
// Create a "reducer" function that determines what the new state
// should be when something happens in the app
function counterReducer(state = initialState, action) {
  // Reducers usually look at the type of action that happened
  // to decide how to update the state
  switch (action.type) {
    case 'counter/incremented':
      return { ...state, value: state.value + 1 }
    case 'counter/decremented':
      return { ...state, value: state.value - 1 }
    default:
      // If the reducer doesn't care about this action type,
      // return the existing state unchanged
      return state
  }
}
```

Action objects always have a `type` field, which is a string you provide that acts as a unique name for the action. The `type` should be a readable name so that anyone who looks at this code understands what it means. `user/delete`, `counter/increment`.
Note that we update the state immutably by copying the existing state and updating the copy, instead of modifying the original object directly.

### Store

- We can create a store instance by calling the Redux library `createStore` API.

```js
// Create a new Redux store with the `createStore` function,
// and use the `counterReducer` for the update logic
const store = Redux.createStore(counterReducer)
```


### UI

- In any application, the user interface will show existing state on screen. When a user does something, the app will update its data and then redraw the UI with those values.

```js
// Our "user interface" is some text in a single HTML element
const valueEl = document.getElementById('value')

// Whenever the store state changes, update the UI by
// reading the latest store state and showing new data
function render() {
  const state = store.getState()
  valueEl.innerHTML = state.value.toString()
}

// Update the UI with the initial data
render()
// And subscribe to redraw whenever the data changes in the future
store.subscribe(render)
```

### Dispatching Actions

- Finally, we need to respond to user interactions by creating action objects that describe what happened, and dispatching them to the store.
- When we call store.dispatch(action), the store runs the reducer, calculates the updated state, and runs the subscribers to update the UI.

```js
// Handle user inputs by "dispatching" action objects,
// which should describe "what happened" in the app
document.getElementById('increment').addEventListener('click', function () {
  store.dispatch({ type: 'counter/incremented' })
})

document.getElementById('decrement').addEventListener('click', function () {
  store.dispatch({ type: 'counter/decremented' })
})

document
  .getElementById('incrementIfOdd')
  .addEventListener('click', function () {
    // We can write logic to decide what to do based on the state
    if (store.getState().value % 2 !== 0) {
      store.dispatch({ type: 'counter/incremented' })
    }
  })

document
  .getElementById('incrementAsync')
  .addEventListener('click', function () {
    // We can also write async logic that interacts with the store
    setTimeout(function () {
      store.dispatch({ type: 'counter/incremented' })
    }, 1000)
  })
```

## Data Flow

![Data flow in Redux](https://redux.js.org/assets/images/ReduxDataFlowDiagram-49fa8c3968371d9ef6f2a1486bd40a26.gif)
