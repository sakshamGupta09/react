# Redux Store

- There is always a single store in a redux application. Cannot split the store like reducers.
- Some of the responsibilities of store are
- To hold the current application state.
- Allows access to read current state via `store.getState()`.
- Allows state to be updated via `store.dispatch()`.
- Registers listener callbacks via `store.subscribe(listener)`;
- Handles unregistering of listeners via the unsubscribe function returned by` store.subscribe(listener)`.


## Creating a Store

- Every Redux store has a single root reducer function.

```ts
const store = createStore(rootReducer, preloadedState)

```


## Dispatching Actions

```ts
import store from './store'
store.dispatch({ type: 'todos/todoAdded', payload: 'Learn about actions' })
```
- Remember, every time we call `store.dispatch(action)`:
- The store calls the root reducer with current state and action object.
- The store saves the new state returned from the reducer.
- The store calls all the listener subscription callbacks.

## Inside a redux store

```ts
function createStore(reducer, preloadedState) {
  let state = preloadedState
  const listeners = []

  function getState() {
    return state
  }

  function subscribe(listener) {
    listeners.push(listener)
    return function unsubscribe() {
      const index = listeners.indexOf(listener)
      listeners.splice(index, 1)
    }
  }

  function dispatch(action) {
    state = reducer(state, action)
    listeners.forEach(listener => listener())
  }

  dispatch({ type: '@@redux/INIT' })

  return { dispatch, subscribe, getState }
}
```


## Middleware

- To customize the dispatch function of the store.
- Redux middleware provides a third-party extension point between dispatching an action, and the moment it reaches the reducer. People use Redux middleware for logging, crash reporting, talking to an asynchronous API, routing, and more.
- Unlike a reducer, middleware can have side effects inside, including timeouts and other async logic.

## Middleware Use Cases

- Log something to the console.
- Set timeouts
- Make asynchronous API calls.
- Modify the action
- Pause the action or even stop it entirely.


## Using Middleware

```ts
export const print1 = (storeAPI) => (next) => (action) => {
  console.log('1')
  return next(action)
}
```

```ts
import { createStore, applyMiddleware } from 'redux'
import rootReducer from './reducer'
import { print1, print2, print3 } from './exampleAddons/middleware'

const middlewareEnhancer = applyMiddleware(print1, print2, print3)

// Pass enhancer as the second arg, since there's no preloadedState
const store = createStore(rootReducer, middlewareEnhancer)

export default store
```
- When we call `store.dispatch(action)`, we're actually calling the first middleware in the pipeline.
- It passes the action to the next middleware in the pipeline.
- In this case, the action is passed through:
- The print1 middleware (which we see as store.dispatch)
- The print2 middleware
- The print3 middleware
- The original store.dispatch
- The root reducer inside store.
- Unlike a reducer, middleware can have side effects inside, including timeouts and other async logic.
- And since these are all function calls, they all return from that call stack. So, the print1 middleware is the first to run, and the last to finish.

## Writing Custom Middleware

- Redux middleware are written as a series of three nested functions.

```ts
// Middleware written as ES5 functions

// Outer function:
function exampleMiddleware(storeAPI) {
  return function wrapDispatch(next) {
    return function handleAction(action) {
      // Do anything here: pass the action onwards with next(action),
      // or restart the pipeline with storeAPI.dispatch(action)
      // Can also use storeAPI.getState() here

      return next(action)
    }
  }
}
```

```ts
const anotherExampleMiddleware = storeAPI => next => action => {
  // Do something in here, when each action is dispatched

  return next(action)
}
```
