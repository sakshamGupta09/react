# Example App

![Sample todo app mockups](https://redux.js.org/assets/images/todos-app-screenshot-b88cee51d457022943b3697ac0b010a7.png)




## 1. Designing the State Values

- The first step is to figure out the application state and it's structure.
- The app state is always a plain JavaScript object with multiple state values nested inside  it.

```ts
export interface ITodo {
  id: number;
  text: string;
  color: TodoColors;
  completed: boolean;
}

export type TodoStatus = "All" | "Active" | "Completed";

export type TodoColors =
  | "Red"
  | "Yellow"
  | "Green"
  | "Blue"
  | "Orange"
  | "Purple";

export interface ITodoAppState {
  todos: ITodo[];
  filters: {
    status: TodoStatus;
    colors: TodoColors[];
  };
}
```

```ts
import { ITodoAppState } from "./model";

export const todoAppState: ITodoAppState = {
  todos: [],
  filters: {
    status: "All",
    colors: [],
  },
};

```


## 2. Designing Actions

- Think about all the possible user interactions.
- Based on that list of things that can happen, we can create a list of actions that our application will use.
- Choose proper naming conventions and figure out the payload structure.
- Like the state data, actions should contain the smallest amount of information needed to describe what happened.


### Possible user interactions

- Add a new todo entry based on the text the user entered
- Toggle the completed status of a todo
- Select a color category for a todo
- Delete a todo
- Mark all todos as completed
- Clear all completed todos
- Choose a different "completed" filter value
- Add a new color filter
- Remove a color filter

###  list of actions based on user interactions

- `{type: 'todos/todoAdded', payload: todoText}`
- `{type: 'todos/todoToggled', payload: todoId}`
- `{type: 'todos/colorSelected', payload: {todoId, color}}`
- `{type: 'todos/todoDeleted', payload: todoId}`
- `{type: 'todos/allCompleted'}`
- `{type: 'todos/completedCleared'}`
- `{type: 'filters/statusFilterChanged', payload: filterValue}`
- `{type: 'filters/colorFilterChanged', payload: {color, changeType}}`

```ts
import { TodoColors } from "../store.ts/model";

const TODOS_ACTION_PREFIX = "todos";

export enum TODOS_ACTION_TYPES {
  ADD = `${TODOS_ACTION_PREFIX}/todoAdded`,
  UPDATE_STATUS = `${TODOS_ACTION_PREFIX}/todoToggled`,
  UPDATE_COLOR = `${TODOS_ACTION_PREFIX}/colorSelected`,
  DELETE = `${TODOS_ACTION_PREFIX}/todoDeleted`,
  ALL_COMPLETED = `${TODOS_ACTION_PREFIX}/allCompleted`,
  REMOVE_COMPLETED = `${TODOS_ACTION_PREFIX}/removeCompleted`,
}

export type TODOS_ACTIONS =
  | { type: TODOS_ACTION_TYPES.ADD; payload: string }
  | { type: TODOS_ACTION_TYPES.UPDATE_STATUS; payload: number }
  | {
      type: TODOS_ACTION_TYPES.UPDATE_COLOR;
      payload: { id: number; color: TodoColors };
    }
  | { type: TODOS_ACTION_TYPES.DELETE; payload: number }
  | { type: TODOS_ACTION_TYPES.ALL_COMPLETED }
  | { type: TODOS_ACTION_TYPES.REMOVE_COMPLETED };

```

```ts
import { TodoColors, TodoStatus } from "../store.ts/model";

const FILTERS_ACTION_PREFIX = "filters";

export enum FILTERS_ACTION_TYPES {
  UPDATE_STATUS = `${FILTERS_ACTION_PREFIX}/statusUpdated`,
  UPDATE_COLOR = `${FILTERS_ACTION_PREFIX}/colorUpdated`,
}

export type FILTER_ACTIONS =
  | { type: FILTERS_ACTION_TYPES.UPDATE_STATUS; payload: TodoStatus }
  | {
      type: FILTERS_ACTION_TYPES.UPDATE_COLOR;
      payload: { color: TodoColors; changeType: "add" | "remove" };
    };

```


## 3. Writing Reducers

- Reducers are functions that take the `current state` and an `action` as arguments, and return a new state result. In other words, `(state, action) => newState`.
- Since now, we have access to both the arguments in step 1 and step 2, We can implment our reducer.
- A Redux app really only has one reducer function: the "root reducer" function that you will pass to `createStore` later on. That one root reducer function is responsible for handling all of the actions that are dispatched, and calculating what the entire new state result should be every time.
