# Example App

![Sample todo app mockups](https://redux.js.org/assets/images/todos-app-screenshot-b88cee51d457022943b3697ac0b010a7.png)



## 1. Designing the State Values

- The first step is to figure out the application state and it's structure.
- The app state is always a plain JavaScript object with multiple state values nested inside  it.

```ts
export interface ITodo {
  id: number;
  text: string;
  color: TodoColors;
  completed: boolean;
}

export type TodoStatus = "All" | "Active" | "Completed";

export type TodoColors =
  | "Red"
  | "Yellow"
  | "Green"
  | "Blue"
  | "Orange"
  | "Purple";

export interface ITodoAppState {
  todos: ITodo[];
  filters: {
    status: TodoStatus;
    colors: TodoColors[];
  };
}
```

```ts
import { ITodoAppState } from "./model";

export const todoAppState: ITodoAppState = {
  todos: [],
  filters: {
    status: "All",
    colors: [],
  },
};

```


## 2. Designing Actions

- Think about all the possible user interactions.
- Based on that list of things that can happen, we can create a list of actions that our application will use.
- Choose proper naming conventions and figure out the payload structure.
- Like the state data, actions should contain the smallest amount of information needed to describe what happened.


### Possible user interactions

- Add a new todo entry based on the text the user entered
- Toggle the completed status of a todo
- Select a color category for a todo
- Delete a todo
- Mark all todos as completed
- Clear all completed todos
- Choose a different "completed" filter value
- Add a new color filter
- Remove a color filter

###  list of actions based on user interactions

- `{type: 'todos/todoAdded', payload: todoText}`
- `{type: 'todos/todoToggled', payload: todoId}`
- `{type: 'todos/colorSelected', payload: {todoId, color}}`
- `{type: 'todos/todoDeleted', payload: todoId}`
- `{type: 'todos/allCompleted'}`
- `{type: 'todos/completedCleared'}`
- `{type: 'filters/statusFilterChanged', payload: filterValue}`
- `{type: 'filters/colorFilterChanged', payload: {color, changeType}}`

```ts
import { TodoColors } from "../store.ts/model";

const TODOS_ACTION_PREFIX = "todos";

export enum TODOS_ACTION_TYPES {
  ADD = `${TODOS_ACTION_PREFIX}/todoAdded`,
  UPDATE_STATUS = `${TODOS_ACTION_PREFIX}/todoToggled`,
  UPDATE_COLOR = `${TODOS_ACTION_PREFIX}/colorSelected`,
  DELETE = `${TODOS_ACTION_PREFIX}/todoDeleted`,
  ALL_COMPLETED = `${TODOS_ACTION_PREFIX}/allCompleted`,
  REMOVE_COMPLETED = `${TODOS_ACTION_PREFIX}/removeCompleted`,
}

export type TODOS_ACTIONS =
  | { type: TODOS_ACTION_TYPES.ADD; payload: string }
  | { type: TODOS_ACTION_TYPES.UPDATE_STATUS; payload: number }
  | {
      type: TODOS_ACTION_TYPES.UPDATE_COLOR;
      payload: { id: number; color: TodoColors };
    }
  | { type: TODOS_ACTION_TYPES.DELETE; payload: number }
  | { type: TODOS_ACTION_TYPES.ALL_COMPLETED }
  | { type: TODOS_ACTION_TYPES.REMOVE_COMPLETED };

```

```ts
import { TodoColors, TodoStatus } from "../store.ts/model";

const FILTERS_ACTION_PREFIX = "filters";

export enum FILTERS_ACTION_TYPES {
  UPDATE_STATUS = `${FILTERS_ACTION_PREFIX}/statusUpdated`,
  UPDATE_COLOR = `${FILTERS_ACTION_PREFIX}/colorUpdated`,
}

export type FILTER_ACTIONS =
  | { type: FILTERS_ACTION_TYPES.UPDATE_STATUS; payload: TodoStatus }
  | {
      type: FILTERS_ACTION_TYPES.UPDATE_COLOR;
      payload: { color: TodoColors; changeType: "add" | "remove" };
    };

```


## 3. Writing Reducers

- Reducers are functions that take the `current state` and an `action` as arguments, and return a new state result. In other words, `(state, action) => newState`.
- Since now, we have access to both the arguments in step 1 and step 2, We can implment our reducer.
- We must pass initial app state as default value to reducer function.

```ts
import { FILTER_ACTIONS } from "../actions/filter-actions";
import { TODOS_ACTION_TYPES, TODOS_ACTIONS } from "../actions/todo-actions";
import { INITIAL_APP_STATE } from "../store.ts/initial-state";
import { ITodo } from "../store.ts/model";

export default function appReducer(
  state = INITIAL_APP_STATE,
  action: TODOS_ACTIONS | FILTER_ACTIONS
) {
  switch (action.type) {
    case TODOS_ACTION_TYPES.ADD: {
      const nextTodo: ITodo = {
        id: state.todos.length,
        text: action.payload,
        color: "Blue",
        completed: false,
      };
      return { ...state, todos: [...state.todos, nextTodo] };
    }

    case TODOS_ACTION_TYPES.UPDATE_STATUS: {
      const nextTodos = state.todos.map((todo) => {
        if (todo.id === action.payload) {
          return { ...todo, completed: !todo.completed };
        }
        return todo;
      });
      return { ...state, todos: nextTodos };
    }
    default:
      return state;
  }
}

```
- We've only handled 3 actions, but this is already getting a bit long. If we try to handle every action in this one reducer function, it's going to be hard to read it all.
- That's why reducers are typically split into multiple smaller reducer functions - to make it easier to understand and maintain the reducer logic.


## Splitting Reducers

- Redux reducers are typically split apart based on the section of the Redux state that they update.
- Our todo app state currently has two top-level sections: state.todos and state.filters. So, we can split the large root reducer function into two smaller reducers - a todosReducer and a filtersReducer.
- However, there's an important difference here. This file only has to update the todos-related state - it's not nested any more! This is another reason why we split up reducers. Since the todos state is an array by itself, we don't have to copy the outer root state object in here. That makes this reducer easier to read.
- This is called reducer composition, and it's the fundamental pattern of building Redux apps.

```ts
import { TodoColors } from "./store";

const TODOS_ACTION_PREFIX = "todos";

export enum TodoActionTypes {
  ADD = `${TODOS_ACTION_PREFIX}/todoAdded`,
  UPDATE_STATUS = `${TODOS_ACTION_PREFIX}/todoToggled`,
  UPDATE_COLOR = `${TODOS_ACTION_PREFIX}/colorSelected`,
  DELETE = `${TODOS_ACTION_PREFIX}/todoDeleted`,
  ALL_COMPLETED = `${TODOS_ACTION_PREFIX}/allCompleted`,
  REMOVE_COMPLETED = `${TODOS_ACTION_PREFIX}/removeCompleted`,
}

export type TodoAction =
  | { type: TodoActionTypes.ADD; payload: string }
  | { type: TodoActionTypes.UPDATE_STATUS; payload: number }
  | {
      type: TodoActionTypes.UPDATE_COLOR;
      payload: { id: number; color: TodoColors };
    }
  | { type: TodoActionTypes.DELETE; payload: number }
  | { type: TodoActionTypes.ALL_COMPLETED }
  | { type: TodoActionTypes.REMOVE_COMPLETED };

```

```ts
import { TodoAction, TodoActionTypes } from "./actions";
import { INITIAL_TODOS, ITodo } from "./store";

export default function todoReducer(state = INITIAL_TODOS, action: TodoAction) {
  switch (action.type) {
    case TodoActionTypes.ADD: {
      const nextTodo: ITodo = {
        id: state.length,
        text: action.payload,
        color: "Blue",
        completed: false,
      };
      return [...state, nextTodo];
    }

    case TodoActionTypes.UPDATE_STATUS: {
      const nextTodos = state.map((todo) => {
        if (todo.id === action.payload) {
          return { ...todo, completed: !todo.completed };
        }
        return todo;
      });
      return nextTodos;
    }
    default:
      return state;
  }
}

```

```ts
export type TodoColors =
  | "Red"
  | "Yellow"
  | "Green"
  | "Blue"
  | "Orange"
  | "Purple";

export interface ITodo {
  id: number;
  text: string;
  color: TodoColors;
  completed: boolean;
}

export const INITIAL_TODOS: ITodo[] = [];

```


## Combining Reducers

- We now have two separate slice files, each with its own slice reducer function. But, we said earlier that the Redux store needs one root reducer function when we create it.
