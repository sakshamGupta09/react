# Global Application State

- Shared data that can be accessed by multiple components in an application.
- This data can be modified by multiple components and the changes should reflect instantly across the application.

## Examples

- Theme color
- Locale
- Permissions
- Logged in user information
- Roles


## Challenges

- How to store the global state.
- How can components read global state.
- How can components update global state.
- How to inform listeners about the state change.


## Redux

- Redux is a pattern and library for managing global application state.
- Where to store data, how to read data, update it and inform listeners about data change everything is managed by Redux.


## State Management

```tsx
function Counter() {
  // State: a counter value
  const [counter, setCounter] = useState(0)

  // Action: code that causes an update to the state when something happens
  const increment = () => {
    setCounter(prevCounter => prevCounter + 1)
  }

  // View: the UI definition
  return (
    <div>
      Value: {counter} <button onClick={increment}>Increment</button>
    </div>
  )
}
```

- This application has three parts
- `The state`, the data in our application at a given time.
- `The view`, the UI that is rendered using current state of application.
- `The actions`, the user interactions that causes us to update the application state and rerender UI.

![State, actionsa and view](https://redux.js.org/assets/images/one-way-data-flow-04fe46332c1ccb3497ecb04b94e55b97.png)

- This is a very simple example.
- However, If we have to share same state across multiple components, which are situated across different levels in the application, this can become very hard to accomplish. Sometimes, this can be solved with `lifting the state up` but thats doesn't help always.
- One way to solve this is to extract all shared state from components and place it in a central place outside the component tree.
- This is the basic idea behind Redux: a single centralized place to contain the global state in your application, and specific patterns to follow when updating that state to make the code predictable.


## Immutability

- "Mutable" means "changeable". If something is "immutable", it can never be changed.
- JavaScript objects and arrays are all mutable by default. If I create an object, I can change the contents of its fields. If I create an array, I can change the contents as well.
- In order to update values immutably, your code must make copies of existing objects/arrays, and then modify the copies.
- React and Redux expect that all state updates are done immutably.



## Actions

- When users interact with our application, we describe that interaction as `Actions`.
- It's a plain JavaScript object with a `type` and `payload` field.
- `type` is a string that gives a descriptiove name to an action. Convention is to name it like `domain/eventName`.


## Action Creators

- An action creator is a function that creates and returns an action object.
- We typically use these so we don't have to write the action object by hand every time:

```ts
const addTodo = text => {
  return {
    type: 'todos/todoAdded',
    payload: text
  }
}
```

## Reducers

- Reducer is a function that takes currrent state and action object as an argument and return a new state.
- `(state, action) => newState.`
- We can think of a reducer as an event listener. Whenever an action is dispatched reducer runs.


### Reducers must always follow some specific rules:

- They should only calculate the new state value based on the state and action arguments
- They should not modify the current state. State should be updated immutabily.
- They must be pure. No asynchronous code, calculate random values, or any other side effects.


## Store

- The current application state lives in an object called store.

```ts
import { configureStore } from '@reduxjs/toolkit'

const store = configureStore({ reducer: counterReducer })
```


## Dispatch

- The redux store also contains a method called `dispatch`. The only way to update the store is by calling this method with an `action` object.
- The store will run it's `reducer` function and update the value with the new state returned form `reducer` function.
- You can think of dispatching actions as "triggering an event" in the application and `actions` are the information about that event.
