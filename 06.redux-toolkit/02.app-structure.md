# The Counter Example App


## Designing the state structure

- Think of the minimal data needed for the app to work.
- Spend some good amount of time and keep refactoring and refining the state structure.


## Redux Slices

- Our application state can have different independent features or pieces.
- For each independent feature, we create a slice that manages that feature only.
- A slice is a collection of `reducer` and `actions` for a single feature typically defined together in a single file.

## Creating Slice Reducers and Actions

counterSlice.ts

1. Define the structure of the feature.

```ts
export interface CounterState {
  value: number
  status: 'idle' | 'loading' | 'failed'
}
```

2. Define the initial value for the feature.

```ts
const initialState: CounterState = {
  value: 0,
  status: 'idle'
}
```

3. Define the slice which consists of reducers and actions

- Key is the action and value is the reducer function.
- Redux Toolkit allows us to write "mutating" logic in reducers. It doesn't actually mutate the state because it uses the Immer library  which detects changes to a "draft state" and produces a brand new immutable state based off those changes.
- Also we are not returning anything from reducer function.
- Like a typical reducer function, it takes `currentState` and `action` object as argument which can be of type `PayloadAction<>`.
- `createSlice` automatically generates action type, action objects and action creators for us.
- The action type is computes as `name` + key of reducer function. Like `counter/increment`.


```ts
export const counterSlice = createSlice({
  name: 'counter',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    increment: state => {
      // Redux Toolkit allows us to write "mutating" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a "draft state" and produces a brand new
      // immutable state based off those changes
      state.value += 1
    },
    decrement: state => {
      state.value -= 1
    },
    // Use the PayloadAction type to declare the contents of `action.payload`
    incrementByAmount: (state, action: PayloadAction<number>) => {
      state.value += action.payload
    }
  }
})
```

4. Export the generated action creators for use in components

```ts
export const { increment, decrement, incrementByAmount } = counterSlice.actions
```


5. Export the slice reducer for use in the store configuration

```ts
export default counterSlice.reducer
```



## Creating the Redux Store

```ts
export const store = configureStore({
  reducer: {
    counter: counterReducer
  }
})

// Infer the type of `store`
export type AppStore = typeof store
export type RootState = ReturnType<AppStore['getState']>
// Infer the `AppDispatch` type from the store itself
export type AppDispatch = AppStore['dispatch']
// Define a reusable type describing thunk functions
export type AppThunk<ThunkReturnType = void> = ThunkAction<
  ThunkReturnType,
  RootState,
  unknown,
  Action
>
```

- If our application has different features, each feature will have it's own slice. We need to pass all those slice to the reducer object of `configureStore` function.
- The final app state will depend on the names of the key we have passed.


## Reading Data with Selectors

- We can call `store.getState()` to get the entire current root state object, and access its fields like `state.counter.value`.
- Selector functions allows us to select a value from the Redux root state.

```ts
// Selector functions allows us to select a value from the Redux root state.
// Selectors can also be defined inline in the `useSelector` call
// in a component, or inside the `createSlice.selectors` field.
export const selectCount = (state: RootState) => state.counter.value
export const selectStatus = (state: RootState) => state.counter.status
```



## Writing Async Logic with Thunks

- So far, all the logic in our application has been synchronous.
- We call the `dipatch` function with action object. It sends an action onject to the `store`. Store runs it's `reducer` and calculates the new state. `Store` gets updated and the dipatch function finishes. All this is synchronous.
- How to add async logic to our Redux apps.

## Thunk

- Thunk is a function that has some async logic. Thunks are written using two functions:
- An inner thunk function, which gets `dispatch` and `getState` as arguments.
- The outer action creator function, which creates and returns the thunk function.

```ts
// The function below is called a thunk, which can contain both sync and async logic
// that has access to both `dispatch` and `getState`. They can be dispatched like
// a regular action: `dispatch(incrementIfOdd(10))`.
// Here's an example of conditionally dispatching actions based on current state.
export const incrementIfOdd = (amount: number): AppThunk => {
  return (dispatch, getState) => {
    const currentValue = selectCount(getState())
    if (currentValue % 2 === 1) {
      dispatch(incrementByAmount(amount))
    }
  }
}
```
- Reducer function used to have current state but thunk does not so it receives getState as an argument, performs some asymc task and then dispatches an action and sync flow continues again.


## Making a network call with Thunk


```ts
// the outside "thunk creator" function
const fetchUserById = (userId: string): AppThunk => {
  // the inside "thunk function"
  return async (dispatch, getState) => {
    try {
      dispatch(userPending())
      // make an async call in the thunk
      const user = await userAPI.fetchById(userId)
      // dispatch an action when we get the response back
      dispatch(userLoaded(user))
    } catch (err) {
      // If something went wrong, handle it here
    }
  }
}
```

- The `createAsyncThunk` method is used to generate thunks that dispatch `pending/fulfilled/rejected` actions based on a promise.

```ts
// Thunks are commonly used for async logic like fetching data.
// The `createAsyncThunk` method is used to generate thunks that
// dispatch pending/fulfilled/rejected actions based on a promise.
// In this example, we make a mock async request and return the result.
// The `createSlice.extraReducers` field can handle these actions
// and update the state with the results.
export const incrementAsync = createAsyncThunk(
  'counter/fetchCount',
  async (amount: number) => {
    const response = await fetchCount(amount)
    // The value we return becomes the `fulfilled` action payload
    return response.data
  }
)
```

- When you use createAsyncThunk, you handle its actions in createSlice.extraReducers. 

```ts
export const counterSlice = createSlice({
  name: 'counter',
  initialState,
  reducers: {
    // omit reducers
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: builder => {
    builder
      // Handle the action types defined by the `incrementAsync` thunk defined below.
      // This lets the slice reducer update the state with request status and results.
      .addCase(incrementAsync.pending, state => {
        state.status = 'loading'
      })
      .addCase(incrementAsync.fulfilled, (state, action) => {
        state.status = 'idle'
        state.value += action.payload
      })
      .addCase(incrementAsync.rejected, state => {
        state.status = 'failed'
      })
  }
})
```


## The React Counter Component

```ts
import { useState } from 'react'

// Use pre-typed versions of the React-Redux
// `useDispatch` and `useSelector` hooks
import { useAppDispatch, useAppSelector } from '@/app/hooks'
import {
  decrement,
  increment,
  incrementAsync,
  incrementByAmount,
  incrementIfOdd,
  selectCount,
  selectStatus
} from './counterSlice'

import styles from './Counter.module.css'

export function Counter() {
  const dispatch = useAppDispatch()
  const count = useAppSelector(selectCount)
  const status = useAppSelector(selectStatus)
  const [incrementAmount, setIncrementAmount] = useState('2')

  const incrementValue = Number(incrementAmount) || 0

  return (
    <div>
      <div className={styles.row}>
        <button
          className={styles.button}
          aria-label="Decrement value"
          onClick={() => {
            dispatch(decrement())
          }}
        >
          -
        </button>
        <span aria-label="Count" className={styles.value}>
          {count}
        </span>
        <button
          className={styles.button}
          aria-label="Increment value"
          onClick={() => {
            dispatch(increment())
          }}
        >
          +
        </button>
        {/* omit additional rendering output here */}
      </div>
    </div>
  )
}
```


## Reading Data with useSelector

- First, the useSelector hook lets our component extract whatever pieces of data it needs from the Redux store state.
- If we had access to a Redux store, we could retrieve the current counter value as:

```ts
const count = selectCount(store.getState())
console.log(count)
// 0
```

- We don't have to only use selectors that have already been exported, either. For example, we could write a selector function as an inline argument to useSelector:
- Any time an action has been dispatched and the Redux store has been updated, useSelector will re-run our selector function. If the selector returns a different value than last time, useSelector will make sure our component re-renders with the new value.


## Dispatching Actions with useDispatch

- To update the store, we need to dispatch actions.
- We use `useDispatch` hook to do so.

```ts
const dispatch = useDispatch();

<button
  className={styles.button}
  aria-label="Increment value"
  onClick={() => {
    dispatch(increment())
  }}
>
  +
</button>
```
```ts
const countPlusTwo = useSelector((state: RootState) => state.counter.value + 2)

```


## Defining Pre-Typed React-Redux Hooks

- By default the useSelector hook needs you to declare (state: RootState) for every selector function. We can create pre-typed versions of the useSelector and useDispatch hooks so that we don't have to keep repeating the : RootState part every time.

```ts
import { useDispatch, useSelector } from 'react-redux'
import type { AppDispatch, RootState } from './store'

// Use throughout your app instead of plain `useDispatch` and `useSelector`
export const useAppDispatch = useDispatch.withTypes<AppDispatch>()
export const useAppSelector = useSelector.withTypes<RootState>()
```


## Providing the Store
