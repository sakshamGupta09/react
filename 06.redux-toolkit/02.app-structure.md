# The Counter Example App


## Designing the state structure

- Think of the minimal data needed for the app to work.
- Spend some good amount of time and keep refactoring and refining the state structure.


## Redux Slices

- Our application state can have different independent features or pieces.
- For each independent feature, we create a slice that manages that feature only.
- A slice is a collection of `reducer` and `actions` for a single feature typically defined together in a single file.

## Creating Slice Reducers and Actions

counterSlice.ts

1. Define the structure of the feature.

```ts
export interface CounterState {
  value: number
  status: 'idle' | 'loading' | 'failed'
}
```

2. Define the initial value for the feature.

```ts
const initialState: CounterState = {
  value: 0,
  status: 'idle'
}
```

3. Define the slice which consists of reducers and actions

- Key is the action and value is the reducer function.
- Redux Toolkit allows us to write "mutating" logic in reducers. It doesn't actually mutate the state because it uses the Immer library  which detects changes to a "draft state" and produces a brand new immutable state based off those changes.
- Also we are not returning anything from reducer function.
- Like a typical reducer function, it takes `currentState` and `action` object as argument which can be of type `PayloadAction<>`.
- `createSlice` automatically generates action type, action objects and action creators for us.
- The action type is computes as `name` + key of reducer function. Like `counter/increment`.


```ts
export const counterSlice = createSlice({
  name: 'counter',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    increment: state => {
      // Redux Toolkit allows us to write "mutating" logic in reducers. It
      // doesn't actually mutate the state because it uses the Immer library,
      // which detects changes to a "draft state" and produces a brand new
      // immutable state based off those changes
      state.value += 1
    },
    decrement: state => {
      state.value -= 1
    },
    // Use the PayloadAction type to declare the contents of `action.payload`
    incrementByAmount: (state, action: PayloadAction<number>) => {
      state.value += action.payload
    }
  }
})
```

4. Export the generated action creators for use in components

```ts
export const { increment, decrement, incrementByAmount } = counterSlice.actions
```


5. Export the slice reducer for use in the store configuration

```ts
export default counterSlice.reducer
```



## Creating the Redux Store

```ts
export const store = configureStore({
  reducer: {
    counter: counterReducer
  }
})

// Infer the type of `store`
export type AppStore = typeof store
export type RootState = ReturnType<AppStore['getState']>
// Infer the `AppDispatch` type from the store itself
export type AppDispatch = AppStore['dispatch']
// Define a reusable type describing thunk functions
export type AppThunk<ThunkReturnType = void> = ThunkAction<
  ThunkReturnType,
  RootState,
  unknown,
  Action
>
```

- If our application has different features, each feature will have it's own slice. We need to pass all those slice to the reducer object of `configureStore` function.
- The final app state will depend on the names of the key we have passed.


## Reading Data with Selectors

- We can call `store.getState()` to get the entire current root state object, and access its fields like `state.counter.value`.
- Selector functions allows us to select a value from the Redux root state.

```ts
// Selector functions allows us to select a value from the Redux root state.
// Selectors can also be defined inline in the `useSelector` call
// in a component, or inside the `createSlice.selectors` field.
export const selectCount = (state: RootState) => state.counter.value
export const selectStatus = (state: RootState) => state.counter.status
```



## Writing Async Logic with Thunks

- So far, all the logic in our application has been synchronous.
- We call the `dipatch` function with action object. It sends an action onject to the `store`. Store runs it's `reducer` and calculates the new state. `Store` gets updated and the dipatch function finishes. All this is synchronous.
- How to add async logic to our Redux apps.

## Thunk

- Thunk is a function that has some async logic. Thunks are written using two functions:
- An inner thunk function, which gets `dispatch` and `getState` as arguments.
- The outer creator function, which creates and returns the thunk function.
- The next function that's exported from counterSlice is an example of a thunk action creator:

```ts
// The function below is called a thunk, which can contain both sync and async logic
// that has access to both `dispatch` and `getState`. They can be dispatched like
// a regular action: `dispatch(incrementIfOdd(10))`.
// Here's an example of conditionally dispatching actions based on current state.
export const incrementIfOdd = (amount: number): AppThunk => {
  return (dispatch, getState) => {
    const currentValue = selectCount(getState())
    if (currentValue % 2 === 1) {
      dispatch(incrementByAmount(amount))
    }
  }
}
```
- Reducer function used to have current state but thunk does not so it receives getState as an argument, performs some asymc task and then dispatches an action and sync flow continues again.

