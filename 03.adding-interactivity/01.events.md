# Responding to Events

- Declare a function inside the component and write it's implementation.
- Pass this function as a prop to JSX element.
- Whenever the event is triggered, React will invoke the function passed.
- Problem with this approach is how to pass arguments.

```tsx
export default function Button() {
  function handleClick() {
    alert('You clicked me!');
  }

  return (
    <button onClick={handleClick}>
      Click me
    </button>
  );
}

```

## Inline event handler

- This impacts the readability. Our markup can look messy if we write all event handlers code inside markup.
- There is no seperation.
- Useful for short functions.

```tsx
<button onClick={function handleClick() {
  alert('You clicked me!');
}}>

<button onClick={() => {
  alert('You clicked me!');
}}>
```

## Mix of both worlds

```tsx

export default function App() {
  function handleDivClick() {
    console.log("[DIV CLICKED]");
  }

  return <div onClick={() => handleDivClick()}></div>;
}
```

## Naming convention

- It is common to name event handlers as handle followed by the event name. You’ll often see `onClick={handleClick}`, `onMouseEnter={handleMouseEnter}`, and so on.
- If there are multiple buttons, we can call them `handleButtonNameClick`.


## Pitfall

- Functions passed to event handlers must be passed, not called. We must always supply a function definition as event handlers.
- React remembers this function and only invokes it when user interacts.
- Anything inside curly braces is executed right away, if we instead call our functions, they will be invoked during rendering and not on user interactions.

```tsx
// WRONG
<button onClick={handleClick()}>

<button onClick={handleClick}>	
```


## Passing event handlers as props 

- Often we declare an event handler in the parent component and then pass it as props to children.
- Lifting the state up. State now resides in parent component so it will be updated here too. But user interactions happen in child components. So, parent will pass the function as prop to children.
- Reusable components like a custom button component. We will define the handler in parent and pass it as a prop to custom button.
- Naming convention is to name our handler props with a prefix `on` and then name of event. 

## Event propagation 

- Whenever React calls the event handler, it will call it with an argument which is an event object which tells us information about the event.
- Event handlers will also catch events from any children your component might have.
- An event “bubbles” or “propagates” up the tree: it starts with where the event happened, and then goes up the tree.
- Be careful and add handlers only to specific components like buttons and not on generic ones.

```tsx
export default function List() {
  function handleDivClick() {
    console.log("[DIV CLICKED]");
  }

  function handleButton1Click() {
    console.log("[BUTTON 1 CLICKED]");
  }

  function handleButton2Click() {
    console.log("[BUTTON 2 CLICKED]");
  }
  return (
    <div onClick={handleDivClick}>
      <button onClick={handleButton1Click}>BUTTON 1</button>
      <button onClick={handleButton2Click}>BUTTON 2</button>
    </div>
  );
}

```

## Stopping propagation 

- Event handlers receive an event object as their only argument. When React calls our function, it invokes it with an event object.

```tsx
  function handleButton1Click(e: React.MouseEvent<HTMLButtonElement>) {
    console.log("[BUTTON 1 CLICKED]");
    e.stopPropagation();
  }
```

## Passing handlers as alternative to propagation 

- We were passing event handlers as props to child components.
- But why don't we use propogation instead? Whenever child component triggers an event it will be captured by parent.
- So why pass the event handler?
- Wou can clearly follow the whole chain of code that executes as a result of some event.
- If you rely on propagation and it’s difficult to trace which handlers execute and why, try this approach instead.


## Can event handlers have side effects? 

- Absolutely! Event handlers are the best place for side effects.
- Event handlers are not part of rendering logic. They get invoked in response to a certain interaction.
