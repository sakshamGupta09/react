# useRef

- To store some information in a component that is not used in rendering logic.
- Since, it is not used in rendering, updating this information should not trigger a new render.
- Component remembers this information across renders just like state but updating it does not trigger a new render.

## Why do we need useRef

- Storing timeout IDs (setTimeout, setInterval).
- Storing and manipulating DOM elements
- Storing other objects that aren’t necessary to calculate the JSX.

## How to use refs

- Import `useRef` from `react`.
- Call the `useRef` hook and provide a initial value.
- Calling this hook returns an object which has a current property whose value is the initial value.
- We can read the value using `ref.current` and we can mutate it also (Mutable not immutable).

``` tsx
import { useRef } from 'react';

export default function Counter() {
  let ref = useRef(0);

  function handleClick() {
    ref.current = ref.current + 1;
    alert('You clicked ' + ref.current + ' times!');
  }

  return (
    <button onClick={handleClick}>
      Click me!
    </button>
  );
}
```

### Stopwatch using refs

```tsx
"use client";

import { useRef, useState } from "react";

export default function Home() {
  const [startTime, setStartTime] = useState<number | null>(null);
  const [now, setNow] = useState<number | null>(null);
  const timerIdRef = useRef<ReturnType<typeof setInterval> | null>(null);

  function handleStartClick() {
    setStartTime(Date.now());
    setNow(Date.now());

    if (timerIdRef.current) {
      clearInterval(timerIdRef.current);
    }

    timerIdRef.current = setInterval(() => {
      setNow(Date.now());
    }, 1000);
  }

  function handleStopClick() {
    if (timerIdRef.current) {
      clearInterval(timerIdRef.current);
    }
  }

  let timePassed = 0;
  if (startTime && now) {
    timePassed = (now - startTime) / 1000;
  }

  return (
    <>
      <h1>Time passed: {timePassed.toFixed(3)}</h1>
      <button onClick={handleStartClick}>Start</button>
      <button onClick={handleStopClick}>Stop</button>
    </>
  );
}

```

<table><thead><tr><th>refs</th><th>state</th></tr></thead><tbody><tr><td><code dir="ltr" class="inline text-code text-secondary dark:text-secondary-dark px-1 rounded-md no-underline bg-gray-30 bg-opacity-10 py-px">useRef(initialValue)</code> returns <code dir="ltr" class="inline text-code text-secondary dark:text-secondary-dark px-1 rounded-md no-underline bg-gray-30 bg-opacity-10 py-px">{ current: initialValue }</code></td><td><code dir="ltr" class="inline text-code text-secondary dark:text-secondary-dark px-1 rounded-md no-underline bg-gray-30 bg-opacity-10 py-px">useState(initialValue)</code> returns the current value of a state variable and a state setter function ( <code dir="ltr" class="inline text-code text-secondary dark:text-secondary-dark px-1 rounded-md no-underline bg-gray-30 bg-opacity-10 py-px">[value, setValue]</code>)</td></tr><tr><td>Doesn’t trigger re-render when you change it.</td><td>Triggers re-render when you change it.</td></tr><tr><td>Mutable—you can modify and update <code dir="ltr" class="inline text-code text-secondary dark:text-secondary-dark px-1 rounded-md no-underline bg-gray-30 bg-opacity-10 py-px">current</code>’s value outside of the rendering process.</td><td>”Immutable”—you must use the state setting function to modify state variables to queue a re-render.</td></tr><tr><td>You shouldn’t read (or write) the <code dir="ltr" class="inline text-code text-secondary dark:text-secondary-dark px-1 rounded-md no-underline bg-gray-30 bg-opacity-10 py-px">current</code> value during rendering.</td><td>You can read state at any time. However, each render has its own <a class="inline text-link dark:text-link-dark border-b border-link border-opacity-0 hover:border-opacity-100 duration-100 ease-in transition leading-normal" href="/learn/state-as-a-snapshot">snapshot</a> of state which does not change.</td></tr></tbody></table>
