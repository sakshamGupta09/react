# Effects

- Components follow render and commit process. Render ---> Commit ---> Screen updated ---> Effects.
- Effects run at the end of commit after screen updates.
- Every time your component renders, React will update the screen and then run the code inside `useEffect`.
- By default, effects runs everytime after React updates the screen.


## Declare an Effect 

```tsx
import { useEffect } from 'react';

function MyComponent() {
  useEffect(() => {
    // Code here will run after *every* render
  });
  return <div />;
}
```

#### Video player example

- Imagine we have a video player component which accepts a prop for indicating whether to play or pause the video.
- But `video` tag does not accept any prop. We manually need to call `play` or `pause` method on the DOM node.
- We need to synchronize the value f boolean prop with methods like `play` and `pause`.

```tsx
export default function VideoPlayer({ isPlaying, src }: Props) {
  const videoRef = useRef<HTMLVideoElement>(null);

  useEffect(() => {
    if (isPlaying) {
      videoRef.current?.play();
      return;
    }
    videoRef.current?.pause();
  });

  return <video ref={videoRef} src={src} loop playsInline />;
}
```

## Never set state inside an effect

- By default, Effects run after every render. This is why code like this will produce an infinite loop.
- Setting state triggers rendering.
- The Effect runs, it sets the state, which causes a re-render, which causes the Effect to run, it sets the state again, this causes another re-render, and so on.

```tsx
const [count, setCount] = useState(0);
useEffect(() => {
  setCount(count + 1);
});
```


## Effect dependencies

- By default effects run after every render. Often this is not what we want.
- We want our effects to run only if one or more dependencies have changed from previous render.
- When it's time to run the effect again, React first compares the dependency values to that of previous render and then runs the effect only if one or more values have changed.
- React compares the dependency values using the Object.is comparison.
- To choose dependencies, just observe what all props or state, this effect is using in side the function.

```tsx
  useEffect(() => {
    // ...
  }, []);
```

```tsx
useEffect(() => {
  // This runs after every render
});

useEffect(() => {
  // This runs only on mount (when the component appears)
}, []);

useEffect(() => {
  // This runs on mount *and also* if either a or b have changed since the last render
}, [a, b]);
```

### Why was the ref omitted from the dependency array? 

```tsx
function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);
  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  }, [isPlaying]);
```

- The effect uses both `isPlaying` and `ref` but only `isPlaying` is added as a dependency.
- `ref` object has a stable identity. React guarantees youâ€™ll always get the same object from the same useRef call on every render.
- It never changes, so it will never by itself cause the Effect to re-run.
- The set functions returned by useState also have stable identity, so you will often see them omitted from the dependencies too.
