# Effects

- Effects run at the end of `commit` after the screen updates.
- To  run some code(side effects) after screen has been updated, we use effects.
- It's like an event which is triggered everytime react updates the screen, and runs our effect code.

## How to write an Effect 

### Step 1: Declare an Effect 

- Every time your component renders, React will update the screen and then run the code inside `useEffect`.
- `useEffect` “delays” a piece of code from running until that render is reflected on the screen.

```tsx
import { useEffect } from 'react';

function MyComponent() {
  useEffect(() => {
    // Code here will run after *every* render
  });
  return <div />;
}
```
### Video player example

- Consider a <VideoPlayer> React component. It would be nice to control whether it’s playing or paused by passing an `isPlaying` prop to it

```tsx
function VideoPlayer({ src, isPlaying }) {
  // TODO: do something with isPlaying
  return <video src={src} />;
}
```
- However, the browser <video> tag does not have an `isPlaying` prop. We manually need to call play or pause methos on video element.
- We need to synchronize the value of isPlaying prop with calls like play() and pause().
- We’ll need to first get a ref to the <video> DOM node.

### Wrong approach

- You might be tempted to try to call play() or pause() during rendering, but that isn’t correct:

```tsx
function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);

  if (isPlaying) {
    ref.current.play();  // Calling these while rendering isn't allowed.
  } else {
    ref.current.pause(); // Also, this crashes.
  }

  return <video ref={ref} src={src} loop playsInline />;
}

```
- In React, rendering should be a pure calculation of JSX and should not contain side effects like modifying the DOM.
- We should never read or write to refs during rendering. Because if it's the first render, React has not added the nodes to the screen. if it's a rerender, React has not yet updated the DOM nodes.

### With effects

- By wrapping the DOM update in an Effect, you let React update the screen first. Then your Effect runs.

```tsx
export default function VideoPlayer({ isPlaying, src }: Props) {
  const videoRef = useRef<HTMLVideoElement>(null);

  useEffect(() => {
    if (isPlaying) {
      videoRef.current?.play();
      return;
    }
    videoRef.current?.pause();
  });

  return <video ref={videoRef} src={src} loop playsInline />;
}
```

