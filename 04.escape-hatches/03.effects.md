# Effects

- Components follow render and commit process. Render ---> Commit ---> Screen updated ---> Effects.
- Everytime React does this process, I want to execute some code after it.
- Every time your component renders, React will update the screen and then run the code inside `useEffect`.
- By default, effects runs everytime after React updates the screen.


## STEP1: Declare an Effect 

```tsx
import { useEffect } from 'react';

function MyComponent() {
  useEffect(() => {
    // Code here will run after *every* render
  });
  return <div />;
}
```

#### Video player example

- Imagine we have a video player component which accepts a prop for indicating whether to play or pause the video.
- But `video` tag does not accept any prop. We manually need to call `play` or `pause` method on the DOM node.
- We need to synchronize the value of boolean prop with methods like `play` and `pause`.

```tsx
export default function VideoPlayer({ isPlaying, src }: Props) {
  const videoRef = useRef<HTMLVideoElement>(null);

  useEffect(() => {
    if (isPlaying) {
      videoRef.current?.play();
      return;
    }
    videoRef.current?.pause();
  });

  return <video ref={videoRef} src={src} loop playsInline />;
}
```

## Never set state inside an effect

- By default, Effects run after every render. This is why code like this will produce an infinite loop.
- Setting state triggers rendering.
- The Effect runs, it sets the state, which causes a re-render, which causes the Effect to run, it sets the state again, this causes another re-render, and so on.

```tsx
const [count, setCount] = useState(0);
useEffect(() => {
  setCount(count + 1);
});
```


## STEP 2: Effect dependencies

- By default effects run after every render. Often this is not what we want.
- We want our effects to run only if one or more dependencies have changed from previous render.
- When it's time to run the effect again, React first compares the dependency values to that of previous render and then runs the effect only if one or more values have changed.
- React compares the dependency values using the Object.is comparison.
- To choose dependencies, just observe what all props or state, this effect is using in side the function.
- This also serves as a depemdency change handler.

```tsx
  useEffect(() => {
    // ...
  }, []);
```

```tsx
useEffect(() => {
  // This runs after every render
});

useEffect(() => {
  // This runs only on mount (appears on the screen for the first time.)
}, []);

useEffect(() => {
  // This runs on mount *and also* if either a or b have changed since the last render
}, [a, b]);
```

### Why was the ref omitted from the dependency array? 

```tsx
function VideoPlayer({ src, isPlaying }) {
  const ref = useRef(null);
  useEffect(() => {
    if (isPlaying) {
      ref.current.play();
    } else {
      ref.current.pause();
    }
  }, [isPlaying]);
```

- The effect uses both `isPlaying` and `ref` but only `isPlaying` is added as a dependency.
- `ref` object has a stable identity. React guarantees youâ€™ll always get the same object from the same useRef call on every render.
- It never changes, so it will never by itself cause the Effect to re-run.
- The set functions returned by useState also have stable identity, so you will often see them omitted from the dependencies too.

## STEP 3: Cleanup

- Imagine we are building a component where we need to connect to a remote server like websocket.
- Doing it on every render is expensive and unnecessary so we would do it only on mounting of component.
- Now imagine we have a big application wherein user switches between pages. During switching or chat component gets unmounted and remounted.
- Whenever it remounts, it sets a new connection. But the previous connection was never destroyed. This can lead to unexpected bugs.
- So it's important to cleanup previous connection.
- Subscriptions, event listeners etc should always be cleaned up.

```tsx
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []);
```
- React calls this cleanup function everytime effect runs again. And also when the component unmounts.
