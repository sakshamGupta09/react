# Effects

- Components follow render and commit process. Render ---> Commit ---> Screen updated ---> Effects.
- Effects run at the end of commit after screen updates.
- Every time your component renders, React will update the screen and then run the code inside `useEffect`.
- By default, effects runs everytime after React updates the screen.


## Declare an Effect 

```tsx
import { useEffect } from 'react';

function MyComponent() {
  useEffect(() => {
    // Code here will run after *every* render
  });
  return <div />;
}
```

#### Video player example

- Imagine we have a video player component which accepts a prop for indicating whether to play or pause the video.
- But `video` tag does not accept any prop. We manually need to call `play` or `pause` method on the DOM node.
- We need to synchronize the value f boolean prop with methods like `play` and `pause`.

```tsx
export default function VideoPlayer({ isPlaying, src }: Props) {
  const videoRef = useRef<HTMLVideoElement>(null);

  useEffect(() => {
    if (isPlaying) {
      videoRef.current?.play();
      return;
    }
    videoRef.current?.pause();
  });

  return <video ref={videoRef} src={src} loop playsInline />;
}
```

## Never set state inside an effect

- By default, Effects run after every render. This is why code like this will produce an infinite loop.
- Setting state triggers rendering.
- The Effect runs, it sets the state, which causes a re-render, which causes the Effect to run, it sets the state again, this causes another re-render, and so on.

```tsx
const [count, setCount] = useState(0);
useEffect(() => {
  setCount(count + 1);
});
```
