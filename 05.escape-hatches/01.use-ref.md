# useRef

- A component should remember some information across renders.
- Updating that information should not trigger new renders.
- Which simply means this information is not relevant for UI and UI does not need to update when this information updates.


## How to use refs

- Call the hook with initial value.
- It returns an object which has a property current that refers to the value.

```tsx
const ref = useRef(0);

{ 
  current: 0 // The value you passed to useRef
}
```

## Patterns

## 1. Persisting Values like timerIds (timeout, intervals)

- Whenever we have to cancel the ongoing interval or timeout, we need to store the unique ID.
- We cannot store it in local variable as it will get overridden for every new render.
- We can use state variable, but that would cause unneccasary renders everytime ID changes.

Lets build a stopwatch which has a start and a stop button and displays the time elapsed after the user pressed start.

```tsx
export default function App() {
  const [start, setStart] = useState<number | null>(null);
  const [now, setNow] = useState<number | null>(null);

  const intervalRef = useRef<ReturnType<typeof setInterval>>(0);

  function handleStartClick() {
    setStart(Date.now());
    setNow(Date.now());

    intervalRef.current && clearInterval(intervalRef.current);

    intervalRef.current = setInterval(() => {
      setNow(Date.now());
    }, 1000);
  }

  function handleStopClick() {
    clearInterval(intervalRef.current);
  }

  let timeElapsed = 0;

  if (start && now) {
    timeElapsed = (now - start) / 1000;
  }

  return (
    <>
      <p>{timeElapsed.toFixed(3)}</p>
      <button onClick={handleStartClick}>START</button>
      <button onClick={handleStopClick}>STOP</button>
    </>
  );
}
```


## 2. Getting Previous Prop or State
