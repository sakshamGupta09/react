# You Might Not Need an Effect

## 1. Updating state based on props or state 

- We have a component that has some state or props.
- We want to transform these values before rendering them. And when the values change, this computed value should update too.
- We might think of having a new state variable and updating it inside an effect.

```tsx
function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');

  // ðŸ”´ Avoid: redundant state and unnecessary Effect
  const [fullName, setFullName] = useState('');
  useEffect(() => {
    setFullName(firstName + ' ' + lastName);
  }, [firstName, lastName]);
  // ...
}
```

- This is inefficient.
- When we set `firstName` variable from 'Taylor' to 'Mark', a render will be queued. During this render we will ask React to give us updated values of all three state variables. The value of `lastName` and `userName` remains unchanged.
- So, React will give us `Mark`, `Swift` and `Taylor Swift`.
- React will render the component with new firstName value and stale userName value.
- Then after updating the screen, React will run the effect which calculates and sets the state variable userName.
- This schedules another render and will get the latest value of username this time.

```tsx
function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');
  // âœ… Good: calculated during rendering
  const fullName = firstName + ' ' + lastName;
  // ...
}
```

- When something can be calculated from the existing props or state, donâ€™t put it in state. Instead, calculate it during rendering.
- Whenever the state gets updated it will automatically transform the values based on latest state or props.

### 2. Caching expensive calculations 

