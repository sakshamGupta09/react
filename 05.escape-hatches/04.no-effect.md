# You Might Not Need an Effect

## 1. Updating state based on props or state 

```tsx
function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');

  // ðŸ”´ Avoid: redundant state and unnecessary Effect
  const [fullName, setFullName] = useState('');
  useEffect(() => {
    setFullName(firstName + ' ' + lastName);
  }, [firstName, lastName]);
  // ...
}
```

```tsx
function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');
  // âœ… Good: calculated during rendering
  const fullName = firstName + ' ' + lastName;
  // ...
}
```

- When something can be calculated from the existing props or state, donâ€™t put it in state. Instead, calculate it during rendering.
- This is more complicated than necessary. It is inefficient too: it does an entire render pass with a stale value for fullName, then immediately re-renders with the updated value. Remove the state variable and the Effect.


### 2. Caching expensive calculations 

```tsx
function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');

  // ðŸ”´ Avoid: redundant state and unnecessary Effect
  const [visibleTodos, setVisibleTodos] = useState([]);
  useEffect(() => {
    setVisibleTodos(getFilteredTodos(todos, filter));
  }, [todos, filter]);

  // ...
}
```

```tsx
function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  // âœ… This is fine if getFilteredTodos() is not slow.
  const visibleTodos = getFilteredTodos(todos, filter);
  // ...
}
```

```tsx
import { useMemo, useState } from 'react';

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  // âœ… Does not re-run getFilteredTodos() unless todos or filter change
  const visibleTodos = useMemo(() => getFilteredTodos(todos, filter), [todos, filter]);
  // ...
}
```

- Consider a component that takes a list and filter as props and does some expensive calculation and returns another list to render to the UI.
- Like we know, when something can be calculated from state or props, we do not use an effect for it rather calculate the result during rendering.
- But maybe this calculation is an expensive operation and currently it will execute on every render (unlike effects where we specify dependencies) even though some unrelated state might have been updated.


## 3. Resetting all state when a prop changes 

- We have a ProfilePage component which accepts a `userId` as a prop. This component renders a comment field whose value is kept in a state variable.
- Now when the prop changes, the comment value will not reset because React preserves the state if we render same component at same spot.
- We can use Effect to clear the comment whenever the prop changes.
- That is inefficient because it will first render the component and all it's children with stale state and then render again.
- Also this is complicated as we will have to do this for all the children of ProfilePage.
- Instead we can use key prop which tells React to recreate DOM nodes and reset all state whenever the key value changes.

```tsx
export default function ProfilePage({ userId }) {
  const [comment, setComment] = useState('');

  // ðŸ”´ Avoid: Resetting state on prop change in an Effect
  useEffect(() => {
    setComment('');
  }, [userId]);
  // ...
}
```

```tsx
export default function ProfilePage({ userId }) {
  return (
    <Profile
      userId={userId}
      key={userId}
    />
  );
}

function Profile({ userId }) {
  // âœ… This and any other state below will reset on key change automatically
  const [comment, setComment] = useState('');
  // ...
}
```


## 4. Adjusting some state when a prop changes 

- 
