# You Might Not Need an Effect

## You donâ€™t need Effects to transform data for rendering.

- Data transformations should be done in the top level of components. That code will automatically re-run whenever your props or state change.
- Whenever state changes, React calls the function to calculate what it needs to display on screen. It then commits the changes to the DOM and updates the screen. Then it runs the effect. Now if we again set state in an effect the process restarts from scratch which is inefficient.


## You donâ€™t need Effects to handle user events. 

- User interactions must be handled in an event handler.


## 1. Updating state based on props or state 

```tsx
function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');

  // ðŸ”´ Avoid: redundant state and unnecessary Effect
  const [fullName, setFullName] = useState('');
  useEffect(() => {
    setFullName(firstName + ' ' + lastName);
  }, [firstName, lastName]);
  // ...
}
```

```tsx
function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');
  // âœ… Good: calculated during rendering
  const fullName = firstName + ' ' + lastName;
  // ...
}
```

- When something can be calculated from the existing props or state, donâ€™t put it in state. Instead, calculate it during rendering.
- This is more complicated than necessary. It is inefficient too: it does an entire render pass with a stale value for fullName, then immediately re-renders with the updated value. Remove the state variable and the Effect.


### 2. Caching expensive calculations 

```tsx
function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');

  // ðŸ”´ Avoid: redundant state and unnecessary Effect
  const [visibleTodos, setVisibleTodos] = useState([]);
  useEffect(() => {
    setVisibleTodos(getFilteredTodos(todos, filter));
  }, [todos, filter]);

  // ...
}
```

```tsx
function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  // âœ… This is fine if getFilteredTodos() is not slow.
  const visibleTodos = getFilteredTodos(todos, filter);
  // ...
}
```

```tsx
import { useMemo, useState } from 'react';

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  // âœ… Does not re-run getFilteredTodos() unless todos or filter change
  const visibleTodos = useMemo(() => getFilteredTodos(todos, filter), [todos, filter]);
  // ...
}
```

- Consider a component that takes a list and filter as props and does some expensive calculation and returns another list to render to the UI.
- Like we know, when something can be calculated from state or props, we do not use an effect for it rather calculate the result during rendering.
- But maybe this calculation is an expensive operation and currently it will execute on every render (unlike effects where we specify dependencies) even though some unrelated state might have been updated.
