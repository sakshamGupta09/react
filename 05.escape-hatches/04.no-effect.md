# You Might Not Need an Effect

## 1. Updating state based on props or state 

- We have a component that has some state or props.
- We want to transform these values before rendering them. And when the values change, this computed value should update too.
- We might think of having a new state variable and updating it inside an effect.

```tsx
function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');

  // ðŸ”´ Avoid: redundant state and unnecessary Effect
  const [fullName, setFullName] = useState('');
  useEffect(() => {
    setFullName(firstName + ' ' + lastName);
  }, [firstName, lastName]);
  // ...
}
```

- This is inefficient.
- When we set `firstName` variable from 'Taylor' to 'Mark', a render will be queued. During this render we will ask React to give us updated values of all three state variables. The value of `lastName` and `userName` remains unchanged.
- So, React will give us `Mark`, `Swift` and `Taylor Swift`.
- React will render the component with new firstName value and stale userName value.
- Then after updating the screen, React will run the effect which calculates and sets the state variable userName.
- This schedules another render and will get the latest value of username this time.

```tsx
function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');
  // âœ… Good: calculated during rendering
  const fullName = firstName + ' ' + lastName;
  // ...
}
```

- When something can be calculated from the existing props or state, donâ€™t put it in state. Instead, calculate it during rendering.
- Whenever the state gets updated it will automatically transform the values based on latest state or props.



### 2. Caching expensive calculations 

- Derived values should be computed during rendering.
- But what if we have an expensive calculation? Since we are doing computations during rendering, this will always run even if unrelated state has updated.
- Effect provided us a way to only run if dependencies have changed.
- In that case we can memoize or cache the results of expensive calculation and some dependencies too using `useMmemo`.

```tsx
import { useMemo, useState } from 'react';

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  // âœ… Does not re-run getFilteredTodos() unless todos or filter change
  const visibleTodos = useMemo(() => getFilteredTodos(todos, filter), [todos, filter]);
  // ...
}
```


## 3. Resetting all state when a prop changes 

