# Manipulating the DOM with Refs

- React automatically updates the DOM with the render output that we return from a component.
- Our focus should be on returning the right JSX output and React handles the rest for us.
- But sometimes we might need to access DOM nodes to handle some scenarios like to focus a node, scroll to it, or measure its size and position. 


## Getting a ref to the node 

```tsx
import { useRef } from 'react';

const myRef = useRef(null);

<div ref={myRef}>

```

## When React attaches the refs 

- In React, every update is split in two phases
- During render, React calls your components to figure out what should be on the screen.
- During commit, React applies changes to the DOM.
- In general, you don’t want to access refs during rendering.
- During the first render, the DOM nodes have not yet been created, so ref.current will be null.
- And during the rendering of updates, the DOM nodes haven’t been updated yet. So it’s too early to read them.
- After updating the DOM or creating new nodes, React immediately sets them to the corresponding DOM nodes.


## Example: Focusing a text input 

```tsx
  const inputRef = useRef<HTMLInputElement>(null);

  function handleClick() {
    inputRef.current?.focus();
  }

  return (
    <>
      <input type="text" ref={inputRef} />
      <button onClick={handleClick}>FOCUS INPUT</button>
    </>
  );
```


## ref callback 

- React automatically assigns value to our ref variable after updating the screen. If you want to listen to when an item is added or removed, we can use ref callbacks.
- When the DOM node is added to the screen or updated, React will call your ref callback with the DOM node as the argument.
- When that DOM node is removed, React will call your the cleanup function returned from the callback.
- It's like React is telling us that it has added or removed a node.

```tsx
<div ref={(node) => {
  console.log('Attached', node);

  return () => {
    console.log('Clean up', node)
  }
}}>
```

## Managing list of refs

- Sometimes, we might need a ref to each element in the list.
- One possible way around this is to get a single ref to their parent element, and then use DOM manipulation methods like `querySelectorAll` to “find” the individual child nodes from it.

```tsx
  const listRef = useRef<HTMLUListElement>(null);

  function handleScrollClick(index: number) {
    const parent = listRef.current;
    if (!parent) {
      return;
    }
    const children = parent.querySelectorAll(".post");
    children[index-1].scrollIntoView({
      behavior: "smooth",
      block: "center",
      inline: "center",
    });
  }

  return (
    <section>
      <div>
        <button onClick={() => handleScrollClick(30)}>SCROLL TO 30</button>
        <button onClick={() => handleScrollClick(60)}>SCROLL TO 60</button>
        <button onClick={() => handleScrollClick(100)}>SCROLL TO 100</button>
      </div>
      <ul className="posts" ref={listRef}>
        {POSTS.map((post, index) => (
          <li key={post.id} className="post">
            <p>POST NO.{index + 1}</p>
            <h2>{post.title}</h2>
            <p>{post.body}</p>
          </li>
        ))}
      </ul>
    </section>
  );
```

Using ref callback

```tsx
  const listRef = useRef<Map<number, HTMLLIElement>>(new Map());

  function handleScrollClick(index: number) {
    const node = listRef.current.get(index-1);
    if (!node) {
      return;
    }
    node.scrollIntoView({
      behavior: "smooth",
      block: "center",
      inline: "center",
    });
  }

  return (
    <section>
      <div>
        <button onClick={() => handleScrollClick(30)}>SCROLL TO 30</button>
        <button onClick={() => handleScrollClick(60)}>SCROLL TO 60</button>
        <button onClick={() => handleScrollClick(100)}>SCROLL TO 100</button>
      </div>
      <ul className="posts">
        {POSTS.map((post, index) => (
          <li
            key={post.id}
            className="post"
            ref={(node) => {
              listRef.current.set(index, node!);
              return () => {
                listRef.current.delete(index);
              };
            }}
          >
            <p>POST NO.{index + 1}</p>
            <h2>{post.title}</h2>
            <p>{post.body}</p>
          </li>
        ))}
      </ul>
    </section>
  );
```

## Accessing another component’s DOM nodes 

